#include <stdio.h>
#include <amss/i2c_client.h>
#include "screen_firmware_update.h"
#include "yftech_mcu_update.h"
#include "log_utils.h"

int start_update_firmware(struct screen_firmware *screen_firmware_p){
	char temp[1024];
	info_out("start_update_firmware\n");
	if(screen_firmware_p != NULL){
	
	    if(screen_firmware_p->protocol != YFTECH_PROTOCOL){
	        if(common_mts_mcu_firmware_update(screen_firmware_p, 0)==MCU_UPDATE_SUCCESSFUL){
			    return 0;
		    }else{
			    goto update_failed;	
		    }
		}
		
		if (screen_firmware_p->i2c_bus >= 0 && screen_firmware_p->i2c_bus < 100) {
			info_out("screen_firmware_p->i2c_bus: %d\n", screen_firmware_p->i2c_bus);
			snprintf(temp, sizeof(temp), "/dev/i2c%d", screen_firmware_p->i2c_bus);
			info_out("temp: %s\n", temp);
			screen_firmware_p->i2c_dev = i2c_open(temp);
			info_out("screen_firmware_p->i2c_dev: %d\n", screen_firmware_p->i2c_dev);
			if (screen_firmware_p->i2c_dev > 0) {
				i2c_set_bus_speed(screen_firmware_p->i2c_dev, I2C_SPEED_STANDARD, NULL);	// 100 kbit/s
			}else{
				err_out("i2c_open failed %d\n", screen_firmware_p->i2c_bus);
				goto update_failed;				
			}
		}else{
			err_out("ilegal i2c bus %s\n", temp);
			goto update_failed;		
		}
		if(screen_firmware_p->protocol == YFTECH_PROTOCOL){
			if(yftech_mts_mcu_firmware_update(screen_firmware_p, 0)==MCU_UPDATE_SUCCESSFUL){
			    if(screen_firmware_p->i2c_dev > 0){
                    i2c_close(screen_firmware_p->i2c_dev);
                    screen_firmware_p->i2c_dev = -1;
	            }
				return 0;			
			}else{
				goto update_failed;			
			}
		}else{
			err_out("start_update_firmware not support protocol:%d\n", screen_firmware_p->protocol);
			goto update_failed;
		}
	}
	
update_failed:
	if(screen_firmware_p->i2c_dev > 0){
        i2c_close(screen_firmware_p->i2c_dev);
        screen_firmware_p->i2c_dev = -1;
	}
	return -1;
}

int start_update_tp_firmware(struct screen_firmware *screen_firmware_p){
	char temp[1024];
	info_out("start_update_tp_firmware\n");
	if(screen_firmware_p != NULL){
		if (screen_firmware_p->i2c_bus >= 0 && screen_firmware_p->i2c_bus < 100) {
			info_out("screen_firmware_p->i2c_bus: %d\n", screen_firmware_p->i2c_bus);
			snprintf(temp, sizeof(temp), "/dev/i2c%d", screen_firmware_p->i2c_bus);
			info_out("temp: %s\n", temp);
			screen_firmware_p->i2c_dev = i2c_open(temp);
			info_out("screen_firmware_p->i2c_dev: %d\n", screen_firmware_p->i2c_dev);
			if (screen_firmware_p->i2c_dev >= 0) {
				i2c_set_bus_speed(screen_firmware_p->i2c_dev, I2C_SPEED_STANDARD, NULL);	// 100 kbit/s
			}else{
				err_out("i2c_open failed %d\n", screen_firmware_p->i2c_bus);
				goto update_failed;				
			}
		}else{
			err_out("ilegal i2c bus %s\n", temp);	
			goto update_failed;
		}
		if(screen_firmware_p->protocol == YFTECH_PROTOCOL){
			if(yftech_mts_mcu_firmware_update(screen_firmware_p, 1)==MCU_UPDATE_SUCCESSFUL){
			    if(screen_firmware_p->i2c_dev > 0){
                    i2c_close(screen_firmware_p->i2c_dev);
                    screen_firmware_p->i2c_dev = -1;
	            }
				return 0;			
			}else{
				goto update_failed;			
			}
		}else{
			err_out("start_update_firmware not support protocol:%d\n", screen_firmware_p->protocol);
			goto update_failed;
		}
	}
	
update_failed:
	if(screen_firmware_p->i2c_dev > 0){
        i2c_close(screen_firmware_p->i2c_dev);
        screen_firmware_p->i2c_dev = -1;
	}
	return -1;
}

int start_update_bridge_firmware(struct screen_firmware *screen_firmware_p){
	char temp[1024];
	info_out("start_update_bridge_firmware\n");
	if(screen_firmware_p != NULL){
		if (screen_firmware_p->i2c_bus >= 0 && screen_firmware_p->i2c_bus < 100) {
			info_out("screen_firmware_p->i2c_bus: %d\n", screen_firmware_p->i2c_bus);
			snprintf(temp, sizeof(temp), "/dev/i2c%d", screen_firmware_p->i2c_bus);
			info_out("temp: %s\n", temp);
			screen_firmware_p->i2c_dev = i2c_open(temp);
			info_out("screen_firmware_p->i2c_dev: %d\n", screen_firmware_p->i2c_dev);
			if (screen_firmware_p->i2c_dev >= 0) {
				i2c_set_bus_speed(screen_firmware_p->i2c_dev, I2C_SPEED_STANDARD, NULL);	// 100 kbit/s
			}else{
				err_out("i2c_open failed %d\n", screen_firmware_p->i2c_bus);
				goto update_failed;				
			}
		}else{
			err_out("ilegal i2c bus %s\n", temp);	
			goto update_failed;
		}
		if(screen_firmware_p->protocol == YFTECH_PROTOCOL){
			if(yftech_mts_mcu_firmware_update(screen_firmware_p, 2)==MCU_UPDATE_SUCCESSFUL){
			    if(screen_firmware_p->i2c_dev > 0){
                    i2c_close(screen_firmware_p->i2c_dev);
                    screen_firmware_p->i2c_dev = -1;
	            }
				return 0;			
			}else{
				goto update_failed;			
			}
		}else{
			err_out("start_update_firmware not support protocol:%d\n", screen_firmware_p->protocol);
			goto update_failed;
		}
	}
	
update_failed:
	if(screen_firmware_p->i2c_dev > 0){
        i2c_close(screen_firmware_p->i2c_dev);
        screen_firmware_p->i2c_dev = -1;
	}
	return -1;
}


/*/
int main(int argc, char *argv[])
{
	int c;
	char temp[1024];
	int n;

	while ((c = getopt(argc, argv,"b:a:p:l")) > 0) {
		if (c == 'l') {
			n = creat(optarg, 0644);
			if (n >= 0) {
				dup2(n, fileno(stdout));
				dup2(n, fileno(stderr));
				setlinebuf(stdout);
				close(n);
			}
		}else if (c == 'b') {
			n = strtoul(optarg, NULL, 0);
			if (n >= 0 && n < 100) {
				snprintf(temp, sizeof(temp), "/dev/i2c%d", n);
				cur_firmware.i2c_dev = i2c_open(temp);
				if (cur_firmware.i2c_dev >= 0) {
					i2c_set_bus_speed(cur_firmware.i2c_dev, I2C_SPEED_STANDARD, NULL);	// 100 kbit/s
				}else{
					printf("i2c_open failed %s\n", temp);
					return -1;				
				}
			}
		} else if(c == 'a'){
			n = strtoul(optarg, NULL, 0);
			printf("-a 0x%x\n", n);
			if (n >= 0 && n < 256){
				cur_firmware.slave_addr = n;
				MCU_I2C_ADDRESS = n;			
			}
		} else if(c == 'p'){
			snprintf(cur_firmware.firmware_path, sizeof(cur_firmware.firmware_path), "%s", optarg);
		}else{
			//do nothing
		}
	}

	return mts_mcu_firmware_update();
}
/*/
